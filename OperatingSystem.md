# OSNote
操作系统相关内容整理

将本人在编程过程中的一些体会，以及网上看到的心得的记录和整理，方便以后自己和团队的参考，提高效率。如果本文对其他开发人员也有所帮助，也欢迎大家给出反馈或者提出改进意见。

*	[内存分配、管理相关](#memory)
*	[网络连接、请求相关](#network)
*	[编译相关](#compile)
*	[进程通讯与调度相关](#process)
*	[面向对象编程相关](#oop)

<h4 id="memory">内存分配、管理相关</h4>
    
内存分配的方式：堆（heap），栈（stack），静态区（static）
*   静态区：保存自动全局变量和static 变量（包括static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配
*   栈：保存局部变量。栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但空间大小有限
*   堆：由malloc 系列函数或new 操作符分配的内存。其生命周期由free 或delete 决定

虚拟内存能将大逻辑地址空间映射到小的物理内存，分页置换算法有FIFO，LRU,但LRU很难实现，一般是近似算法。内存映射是指文件IO像内存一样被访问。
*   分页置换算法：FIFO（最早进入的页面被置换），LRU（最近最少使用），OPT（最佳置换算法，选择在最长时间内不再被访问的页面）

new 和 malloc 的区别
*   malloc是C/C++的标准库函数，new是C++的操作符
*   new返回指定类型的指针，并可以自动计算空间大小；malloc需要用户自己计算大小，本身返回(void *)，需要用户强制转型，如int *p = (int *)malloc(sizeof(int) * 100); free(p);
*   malloc只管内存分配，不进行初始化，所获得空间上的值是随机的；new除了分配内存外，还会初始化，可以调用类的构造函数（对应的delete调用析构函数，而free不调用）

---

<h4 id="network">网络连接、请求相关</h4>

Socket由IP地址和端口号组成，所有小于1024的端口号都是系统服务

应用层协议：http、dns、ftp 传输层协议：tcp、udp 网络层协议: ip

ip协议是指在源地址和目的地址之间传送一种称之为数据报（包），不负责保证传送可靠性；ipv4有32位，ipv6有128位；ip地址分为5类，ABCDE，大型网络（第一段网络号0-127），中型网络（前两段网络号128-191），小型网络（前三段网络号192-255），多目地址，备用

get 和 post 的区别
*   get是从服务器获取数据，post是向服务器发送数据
*   get的参数在url中，用户可见；post的参数在html header中，用户不可见
*   get传送数据较小，post较大

小端和大端
*   Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端；Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端
*   所有网络协议也都是采用big endian的方式来传输数据的，如tcp/ip；windows的字节序为低字节开头；linux,unix的字节序为高字节开头；java则无论平台变化，都是高字节开头
   
    int a = 0x05060708;
    // 在BIG-ENDIAN的情况下存放为：（按照输出的顺序存放）
    // 字节号 0 1 2 3
    // 数据 05 06 07 08
    // 在LITTLE-ENDIAN的情况下存放为：
    // 字节号 0 1 2 3
    // 数据 08 07 06 05

断点续传 Http Header Range:bytes = 2222

---

<h4 id="compile">编译相关</h4>

Gcc编译器对程序的编译可分为4个阶段：预编译、编译和优化、汇编、链接，最后生成可执行文件 
*   预编译：将程序引用的头文件包含进源代码中，并对一些宏定义#define，条件编译指令#ifdef进行替换
*   编译：将用户的可识别语言翻译成汇编代码，主要包括词法分析、语法分析、语义分析及中间码生成4个阶段
*   汇编：将汇编代码翻译为目标机器指令，最终生成对应的目标文件
*   链接：所有的目标文件必须用某种方式组合起来才能运行，这就是链接的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库（静态链接或动态链接库）

内存对齐，char 1字节，short 2字节，int 4字节，long 4字节，float 4字节，double 8字节。对齐时以最大的元素长度基准，进行对齐，所以总大小一定是最大元素长度的倍数

---

<h4 id="process">进程通讯与调度相关</h4>

进程是指放入内存，并且正在执行的程序。进程间的通信方式分为消息传递型（管道、消息队列、信号、信号量、socket（不在同一台机器上的两个进程））和共享内存型。

进程调度算法：FCFS（按先后顺序进行调度），RR（时间片轮转调度，每个进程执行一个时间片），多级反馈队列（多个队列，每个队列有不同的优先级，逐级降低，优先级越高时间片越短，每个进程执行完一个时间片后进入下一层队列），优先级（抢占式和非抢占式，根据优先级决定处理顺序），SJF（短作业优先）

多线程进程中，每个线程有自己独立的寄存器值和栈内存，并且和其他线程共用进程的堆内存和全局变量

信号量包括两个标准的原子操作：wait和signal，或者称为PV操作。信号量分为计数信号量和二进制信号量，计数信号量的值域不受限制，而二进制信号量只能是0或者1，也被称为互斥锁。互斥锁处理时，线程需要睡眠（切换上下文，适用于占用时间长的进程）；自旋锁处理时，线程持续循环查询（无需切换上下文，适用于占用时间短的进程）

死锁的必要条件：互斥、占有并等待、非抢占、循环等待

FIFO是命名管道，先进先出；PIPE是匿名管道，适用于有父子关系的两个进程

并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务；并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头

线程安全：多个线程同时访问一个对象时，该对象工作正常

fork() 会创建一个新进程，返回两次，子进程返回0，父进程返回子进程的id，如 folk() || folk() 共创建3个进程

---

<h4 id="oop">面向对象编程相关</h4>

覆盖（Overriding）和重载（Overloading）的区别：
*   Overriding: 在同一个类中，两个名字相同的方法，只是参数列表不同（参数的个数和类型），在编译时绑定。
*   Overloading: 子类重新定义父类方法（重写方法内容，其他保持一致），在运行时动态绑定。

构造函数负责构造新对象，将对象的数据成员初始化；析构函数由程序自动调用，首先根据用户代码释放占用的堆内存（new 出来的数组），再自动释放占用的栈内存（局部变量）。

多态的表现形式：
*   方法的多态：覆盖，重载
*   对象的多态：向上转型，向下转型

函数前面加const表明返回值不能修改，后面加const表明该方法只能读取类的成员变量，不能修改成员变量
	
	int GetY() const {
	    // 该方法中不能修改成员变量的值
		return yVal;
	}
	void SetY(int value) {
	    // 该方法中可以修改成员变量的值
		y = value;
	}

C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序
	
	class CMyClass {
		CMyClass(int x, int y);
		int m_x;
		int m_y;
	};

	CMyClass::CMyClass(int x, int y) : m_y(y), m_x(m_y)
	{
		// 初始化顺序并不是先m_y=y，然后做m_x=m_y，最后它们有相同的值。编译器先初始化m_x，然后是m_y,，因为它们是按这样的顺序声明的。结果是m_x将有一个不可预测的值
	}
	
---
